// MathLibrary.cpp : Defines the exported functions for the DLL.
#include "pch.h" // use stdafx.h in Visual Studio 2017 and earlier
#include <utility>
#include <limits.h>
#include "MathLibrary.h"
#include <windows.h>
#include <stdio.h>

// DLL internal state variables:
static unsigned long long previous_;  // Previous value, if any
static unsigned long long current_;   // Current sequence value
static unsigned index_;               // Current seq. position

// Initialize a Fibonacci relation sequence
// such that F(0) = a, F(1) = b.
// This function must be called before any other function.
void fibonacci_init(
    const unsigned long long a,
    const unsigned long long b)
{
    index_ = 0;
    current_ = a;
    previous_ = b; // see special case when initialized
}

// Produce the next value in the sequence.
// Returns true on success, false on overflow.
bool fibonacci_next()
{
    // check to see if we'd overflow result or position
    if ((ULLONG_MAX - previous_ < current_) ||
        (UINT_MAX == index_))
    {
        return false;
    }

    // Special case when index == 0, just return b value
    if (index_ > 0)
    {
        // otherwise, calculate next sequence value
        previous_ += current_;
    }
    std::swap(current_, previous_);
    ++index_;
    return true;
}

// Get the current value in the sequence.
unsigned long long fibonacci_current()
{
    return current_;
}

// Get the current index position in the sequence.
unsigned fibonacci_index()
{
    return index_;
}






int main(void)

{

    LPCWSTR szDirPath = L"c:\\Users\\useru\\Desktop\\tarator";

    HANDLE hFile;

    LPCWSTR fname = L"c:\\Users\\useru\\Desktop\\tarator.txt";



    // Create a new directory.

    if (!CreateDirectory(szDirPath, NULL))

        printf("\nCouldn't create %S directory.\n", szDirPath);

    else

        printf("\n%S directory successfully created.\n", szDirPath);



    // Create a file

    hFile = CreateFile(fname, //file to be opened

        GENERIC_READ, //open for writing

        FILE_SHARE_READ, //share for writing

        NULL, //default security

        CREATE_ALWAYS, //create new file only

        FILE_ATTRIBUTE_ARCHIVE | SECURITY_IMPERSONATION,

        //archive and impersonate client

        NULL); //no attribute template



        // Check the handle, then open...

    if (hFile == INVALID_HANDLE_VALUE)

        printf("\nCould not open %S file, error %d)\n", fname, GetLastError());

    else

    {

        printf("\n%S file HANDLE is OK!\n", fname);

        printf("\n%S opened successfully!\n", fname);

    }



    // Close the handle...

    if (CloseHandle(hFile) != 0)

        printf("\nCloseHandle() for %S file succeeded!\n", fname);

    else

        printf("\nCloseHandle() for %S file failed!\n", fname);



    //  if (DeleteFile(fname) != 0)

    //       printf("\n%S file successfully deleted!\n", fname);

    //   else

    //       printf("\n%S file deletion failed!\n", fname);



       // Delete the directory...

     //  if (RemoveDirectory(szDirPath) != 0)

   //        printf("\n%S directory successfully deleted.\n", szDirPath);

   //    else

    //       printf("\n%S directory deletion failed.\n", szDirPath);

    //   return 0;
}